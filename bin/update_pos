#!/bin/sh
# Copyright (c) 2003-2005 Nuxeo SARL <http://nuxeo.com>
# Authors:
# Julien Anguenot <ja@nuxeo.com>
# M.-A. Darche <madarche@nuxeo.com>
# Encolpe Degoute <edegoute@nuxeo.com>
#
# $Id$

prog_name=update_pos
usage="Usage:
$prog_name [options]

  -h, --help
     print help message and exit.  

  -v, --verbose
     print messages and debug information during po file processing.
"

help() {
echo "
$usage
This script scans the skins directory for ZPT files to find strings to
translate. It updates the pot/pos files inside the i18n directory of the product
in which the script is run. Afterward one can then safely and very easily
update the *.po files for untranslated messages.

This script relies on the following software, so make sure they are installed on
your system and available for $prog_name:

  * the GNU Internationalization utilities,
    be sure to have the gettext package (or equivalent)

  * the OpenPTi18n Zope product

This script relies on the PRODUCTS_DIR variable to find the OpenPTi18n product.
So for this script to work, you need to set this variable.

Example:
$ cd /var/lib/zope2.7/instance/instance1/Products/CPSDefault/i18n/
$ export PRODUCTS_DIR=/var/lib/zope2.7/instance/instance1/Products/
$ update_pos --verbose
"
}

if [ ! $Z_NAME ]; then
    ECHO=echo
    PWD=pwd
    RM=rm
    GREP=grep
else
    # Include the Nuxeo specific script inc.sh if it exists
    . inc.sh || exit -1
fi

# If the first argument is "-h" or "--help" display help.
if [[ $1 == "-h" ]] || [[ $1 == "--help" ]]; then
    help; exit 0
fi

# If the first argument is "-h" or "--help" display help.
if [[ $1 == "-v" ]] || [[ $1 == "--verbose" ]]; then
    verbose='True'
else
    verbose=''
fi


# Take the .config.pot from the make_pot
# to get the name of the pot file choosen by
# the user.
get_pot_name() {
    POT_FILE_NAME=`$GREP pot ./.config.pot`
}

# This optional file may be used to eliminate duplicate translations with
# CPSDefault or other products such as CPSSchemas, etc. when a product overide
# some templates. To activate this functionality, you just need to have a
# .blacklist_pot file in your i18n directory.
#
# This file may have multiple lines. Each line of this file must be the path to
# the xxx.pot file of a product.
BLACKLIST_POT_FILE_NAME='.blacklist_pot'


###############
#    MAIN
###############

$ECHO
$ECHO "###################################################################"
$ECHO "### update_pos : Updating the pot/pos files from ZPT's and Custom  "
$ECHO "###################################################################"
$ECHO

if [[ -n $verbose ]]; then
    $ECHO "ZHOME/Z_NAME = $ZHOME/$Z_NAME"
    $ECHO "PRODUCTS_DIR = $PRODUCTS_DIR"
fi

if [ -x $ZHOME/$Z_NAME/bin/python ]; then
    PYTHON_BIN=$ZHOME/$Z_NAME/bin/python
else
    PYTHON_BIN=`which python`
fi

# PRODUCTS_DIR is the only necessary variable that this script needs to get
if [ -z $PRODUCTS_DIR ]; then
    if [ -d $ZHOME/$Z_NAME/Products ]; then
        PRODUCTS_DIR=$ZHOME/$Z_NAME/Products
    else
        PRODUCTS_DIR=`$PWD`/../..
    fi
    if [ -n $verbose ]; then
        $ECHO "Computed PRODUCTS_DIR = $PRODUCTS_DIR"
    fi
fi

if [ ! -d $PRODUCTS_DIR/OpenPTi18n ]; then
    $ECHO "You must install OpenPTi18n in your Products directory"
    exit 1
else
    PARSER_SCRIPT=$PRODUCTS_DIR/OpenPTi18n/i18n_xgettext.py
    # Checking if we are in the i18n directory
    $PWD | grep "i18n" >> /dev/null
    if [ $? -eq 1 ] ; then
        $ECHO "update_pos **needs** to be executed within the i18n directory"
        exit 1
    else
        $PWD | grep "i18n/" >> /dev/null
        if [ $? -eq 0 ] ; then
            $ECHO "update_pos **needs** to be executed within the i18n directory"
            exit 1
        else
            SKINS_PATH="../skins/"

            $ECHO "################################################"
            $ECHO "### Checking .pot and .po files well-formedness"
            $ECHO "################################################"
            $ECHO

            # Checking the user custom.pot file well-formedness
            msgconv custom.pot >> /dev/null
            if [ $? -eq 1 ] ; then
                $ECHO
                $ECHO "##############################################"
                $ECHO "Your custom.pot file is not well-formed!"
                $ECHO "Check file custom.pot"
                $ECHO "Correct the errors and relaunch the program"
                $ECHO "##############################################"
                $ECHO
                exit 1
            fi

            # Generating the .pot file from the ZPTs.
            # Getting the file name to use from the product's configuration
            # file. This file name is $POT_FILE_NAME
            get_pot_name
            chmod a+w $POT_FILE_NAME
            $PYTHON_BIN $PARSER_SCRIPT -o $POT_FILE_NAME $SKINS_PATH

            # Checking the ZPT's file well-formedness
            msgconv $POT_FILE_NAME >> /dev/null
            if [ $? -eq 1 ] ; then
                $ECHO
                $ECHO "##############################################"
                $ECHO "Some ZPT files have some problems!"
                $ECHO "Check file $POT_FILE_NAME"
                $ECHO "Check also ZPT files in verbose/debug mode"
                $ECHO "Correct the errors and relaunch the program"
                $ECHO "##############################################"
                $ECHO
                exit 1
            fi

            # Reading each line of the file with name
            # BLACKLIST_POT_FILE_NAME to find all the files which we want
            # to purge duplicates from.
            #
            # The BLACKLIST_POT_FILE_NAME is an optional file, so we must
            # test that the file exists and is readable before trying to use it.
            if [[ -r $BLACKLIST_POT_FILE_NAME ]]; then
              $ECHO "############################################################"
              $ECHO "### Purging duplicates using file $BLACKLIST_POT_FILE_NAME"
              $ECHO "############################################################"
              PURGED_POT_FILE_NAME="$POT_FILE_NAME.purged"
              while read line; do
                EXISTING_POT_FILE_NAME=$line
                if [[ -n $EXISTING_POT_FILE_NAME ]]; then
                    $ECHO "Purging duplicates from file $EXISTING_POT_FILE_NAME..."
                    msgattrib --only-file=$EXISTING_POT_FILE_NAME \
                    --set-obsolete -no-obsolete -o $PURGED_POT_FILE_NAME $POT_FILE_NAME
                    mv $PURGED_POT_FILE_NAME $POT_FILE_NAME
                fi
              done < $BLACKLIST_POT_FILE_NAME
              $ECHO
            fi

            # Concatenate the custom pot file and the pot file coming from the ZPTs
            msgcat --use-first $POT_FILE_NAME custom.pot -o $POT_FILE_NAME

            chmod a-w $POT_FILE_NAME

            # Merging the po files with the new pot template
            ls *.po | while read po_file ; do
		if [[ -n $verbose ]]; then
                    msgmerge $po_file $POT_FILE_NAME -o $po_file
		else
                    msgmerge $po_file $POT_FILE_NAME -o $po_file 2>/dev/null
		fi
            done

            exit 0
        fi
    fi
fi
